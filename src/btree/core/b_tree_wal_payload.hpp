#pragma once

#include "leanstore/btree/core/b_tree_node.hpp"
#include "leanstore/kv_interface.hpp"
#include "leanstore/units.hpp"
#include "leanstore/utils/log.hpp"

#include <string>

namespace leanstore::storage::btree {

// WAL generated by user transactions
class WalInsert;
class WalTxInsert;
class WalUpdate;
class WalTxUpdate;
class WalRemove;
class WalTxRemove;

/// WAL generated by system transactions
class WalInitPage;
class WalSplitRoot;
class WalSplitNonRoot;

#define DO_WITH_TYPES(ACTION, ...)                                                                 \
  ACTION(kWalInsert, 1, "kWalInsert", __VA_ARGS__)                                                 \
  ACTION(kWalTxInsert, 2, "kWalTxInsert", __VA_ARGS__)                                             \
  ACTION(kWalUpdate, 3, "kWalUpdate", __VA_ARGS__)                                                 \
  ACTION(kWalTxUpdate, 4, "kWalTxUpdate", __VA_ARGS__)                                             \
  ACTION(kWalRemove, 5, "kWalRemove", __VA_ARGS__)                                                 \
  ACTION(kWalTxRemove, 6, "kWalTxRemove", __VA_ARGS__)                                             \
  ACTION(kWalInitPage, 10, "kWalInitPage", __VA_ARGS__)                                            \
  ACTION(kWalSplitRoot, 11, "kWalSplitRoot", __VA_ARGS__)                                          \
  ACTION(kWalSplitNonRoot, 12, "kWalSplitNonRoot", __VA_ARGS__)                                    \
  ACTION(kWalUndefined, 100, "kWalUndefined", __VA_ARGS__)

#define DECR_TYPE(type, type_value, type_name, ...) type = type_value,
#define TYPE_NAME(type, type_value, type_name, ...)                                                \
  case Type::type:                                                                                 \
    return type_name;

class WalPayload {
public:
  enum class Type : uint8_t { DO_WITH_TYPES(DECR_TYPE) };

  /// Type of WalPayload
  Type type_ = Type::kWalUndefined;

  WalPayload() = default;

  WalPayload(Type type) : type_(type) {
  }

  std::string WalLogTypeName(Type type) const {
    switch (type) {
      DO_WITH_TYPES(TYPE_NAME);
    default:
      return "Unknown WAL log type";
    }
  }

  static const WalPayload* From(const void* data) {
    return reinterpret_cast<const WalPayload*>(const_cast<void*>(data));
  }
};

#undef TYPE_NAME
#undef DECR_TYPE
#undef DO_WITH_TYPES

class WalInsert : public WalPayload {
public:
  uint16_t key_size_;

  uint16_t val_size_;

  uint8_t payload_[];

  WalInsert(Slice key, Slice val)
      : WalPayload(Type::kWalInsert),
        key_size_(key.size()),
        val_size_(val.size()) {
    std::memcpy(payload_, key.data(), key_size_);
    std::memcpy(payload_ + key_size_, val.data(), val_size_);
  }

  inline Slice GetKey() const {
    return Slice(payload_, key_size_);
  }

  inline Slice GetVal() const {
    return Slice(payload_ + key_size_, val_size_);
  }
};

class WalTxInsert : public WalPayload {
public:
  uint16_t key_size_;

  uint16_t val_size_;

  WORKERID prev_worker_id_;

  TXID prev_tx_id_;

  COMMANDID prev_command_id_;

  uint8_t payload_[];

  WalTxInsert(Slice key, Slice val, WORKERID prev_worker_id, TXID prev_tx_id,
              COMMANDID prev_command_id)
      : WalPayload(Type::kWalTxInsert),
        key_size_(key.size()),
        val_size_(val.size()),
        prev_worker_id_(prev_worker_id),
        prev_tx_id_(prev_tx_id),
        prev_command_id_(prev_command_id) {
    std::memcpy(payload_, key.data(), key_size_);
    std::memcpy(payload_ + key_size_, val.data(), val_size_);
  }

  Slice GetKey() const {
    return Slice(payload_, key_size_);
  }

  Slice GetVal() const {
    return Slice(payload_ + key_size_, val_size_);
  }
};

class WalUpdate : public WalPayload {
public:
  uint16_t key_size_;

  uint16_t delta_length_;

  uint8_t payload_[];

  WalUpdate() : WalPayload(WalPayload::Type::kWalUpdate) {
  }
};

class WalTxUpdate : public WalPayload {
public:
  uint16_t key_size_;

  uint64_t update_desc_size_;

  uint64_t delta_size_;

  WORKERID prev_worker_id_;

  TXID prev_tx_id_;

  // Xor result of old and new command id
  COMMANDID xor_command_id_;

  // Stores key, UpdateDesc, and Delta in order
  uint8_t payload_[];

  WalTxUpdate(Slice key, UpdateDesc& update_desc, uint64_t size_of_update_desc_and_delta,
              WORKERID prev_worker_id, TXID prev_tx_id, COMMANDID xor_command_id)
      : WalPayload(Type::kWalTxUpdate),
        key_size_(key.size()),
        update_desc_size_(update_desc.Size()),
        delta_size_(size_of_update_desc_and_delta - update_desc.Size()),
        prev_worker_id_(prev_worker_id),
        prev_tx_id_(prev_tx_id),
        xor_command_id_(xor_command_id) {
    // key
    std::memcpy(payload_, key.data(), key.size());
    // updateDesc
    std::memcpy(payload_ + key.size(), &update_desc, update_desc.Size());
  }

  inline Slice GetKey() const {
    return Slice(payload_, key_size_);
  }

  inline const UpdateDesc* GetUpdateDesc() const {
    auto* update_desc = UpdateDesc::From(payload_ + key_size_);
    LEAN_DCHECK(update_desc->Size() == update_desc_size_,
                "Malformed WalTxUpdate: updateDesc->Size() != update_desc_size_, "
                "updateDesc->Size()={}, update_desc_size_={}",
                update_desc->Size(), update_desc_size_);
    return update_desc;
  }

  inline uint8_t* GetDeltaPtr() {
    return payload_ + key_size_ + update_desc_size_;
  }

  inline const uint8_t* GetDeltaPtr() const {
    return payload_ + key_size_ + update_desc_size_;
  }

  uint64_t GetDeltaSize() const {
    return delta_size_;
  }
};

class WalRemove : public WalPayload {
public:
  uint16_t key_size_;

  uint16_t val_size_;

  uint8_t payload_[];

  WalRemove(Slice key, Slice val)
      : WalPayload(Type::kWalRemove),
        key_size_(key.size()),
        val_size_(val.size()) {
    std::memcpy(payload_, key.data(), key.size());
    std::memcpy(payload_ + key.size(), val.data(), val.size());
  }
};

class WalTxRemove : public WalPayload {
public:
  uint16_t key_size_;

  uint16_t val_size_;

  WORKERID prev_worker_id_;

  TXID prev_tx_id_;

  COMMANDID prev_command_id_;

  uint8_t payload_[];

  WalTxRemove(Slice key, Slice val, WORKERID prev_worker_id, TXID prev_tx_id,
              COMMANDID prev_command_id)
      : WalPayload(Type::kWalTxRemove),
        key_size_(key.size()),
        val_size_(val.size()),
        prev_worker_id_(prev_worker_id),
        prev_tx_id_(prev_tx_id),
        prev_command_id_(prev_command_id) {
    std::memcpy(payload_, key.data(), key.size());
    std::memcpy(payload_ + key.size(), val.data(), val.size());
  }

  Slice RemovedKey() const {
    return Slice(payload_, key_size_);
  }

  Slice RemovedVal() const {
    return Slice(payload_ + key_size_, val_size_);
  }
};

class WalInitPage : public WalPayload {
public:
  TXID sys_tx_id_;

  TREEID tree_id_;

  bool is_leaf_;

  WalInitPage(TXID sys_tx_id, TREEID tree_id, bool is_leaf)
      : WalPayload(Type::kWalInitPage),
        sys_tx_id_(sys_tx_id),
        tree_id_(tree_id),
        is_leaf_(is_leaf) {
  }
};

class WalSplitRoot : public WalPayload {
public:
  TXID sys_tx_id_;

  PID new_left_;

  PID new_root_;

  PID meta_node_;

  uint16_t split_slot_;

  uint16_t separator_size_;

  bool separator_truncated_;

  WalSplitRoot(TXID sys_tx_id, PID new_left, PID new_root, PID meta_node,
               const BTreeNode::SeparatorInfo& sep_info)
      : WalPayload(Type::kWalSplitRoot),
        sys_tx_id_(sys_tx_id),
        new_left_(new_left),
        new_root_(new_root),
        meta_node_(meta_node),
        split_slot_(sep_info.slot_id_),
        separator_size_(sep_info.size_),
        separator_truncated_(sep_info.trunc_) {
  }
};

class WalSplitNonRoot : public WalPayload {
public:
  TXID sys_tx_id_;

  PID parent_page_id_;

  PID new_left_;

  uint16_t split_slot_;

  uint16_t separator_size_;

  bool separator_truncated_;

  WalSplitNonRoot() : WalPayload(Type::kWalSplitNonRoot) {
  }

  WalSplitNonRoot(TXID sys_tx_id, PID parent, PID new_left,
                  const BTreeNode::SeparatorInfo& sep_info)
      : WalPayload(Type::kWalSplitNonRoot),
        sys_tx_id_(sys_tx_id),
        parent_page_id_(parent),
        new_left_(new_left),
        split_slot_(sep_info.slot_id_),
        separator_size_(sep_info.size_),
        separator_truncated_(sep_info.trunc_) {
  }
};

} // namespace leanstore::storage::btree
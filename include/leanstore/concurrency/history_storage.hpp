#pragma once

#include "leanstore/common/portable.h"
#include "leanstore/units.hpp"

#include <cstdint>
#include <functional>

namespace leanstore::storage::btree {
class BasicKV;
} // namespace leanstore::storage::btree

namespace leanstore::storage {
class BufferFrame;
} // namespace leanstore::storage

namespace leanstore::cr {

using RemoveVersionCallback = std::function<void(
    const lean_txid_t version_tx_id, const lean_treeid_t tree_id, const uint8_t* version_data,
    uint64_t version_size, const bool visited_before)>;

struct PACKED VersionMeta {
  bool called_before_ = false;

  lean_treeid_t tree_id_;

  uint8_t payload_[];

public:
  inline static const VersionMeta* From(const uint8_t* buffer) {
    return reinterpret_cast<const VersionMeta*>(buffer);
  }

  inline static VersionMeta* From(uint8_t* buffer) {
    return reinterpret_cast<VersionMeta*>(buffer);
  }
};

class HistoryStorage {
private:
  struct ALIGNAS(64) Session {
    leanstore::storage::BufferFrame* rightmost_bf_ = nullptr;

    uint64_t rightmost_version_ = 0;

    int64_t rightmost_pos_ = -1;

    leanstore::storage::BufferFrame* left_most_bf_ = nullptr;

    uint64_t left_most_version_ = 0;

    lean_txid_t last_tx_id_ = 0;
  };

  /// Stores all the update versions generated by the current worker thread.
  leanstore::storage::btree::BasicKV* update_index_;

  /// Stores all the remove versions generated by the current worker thread.
  leanstore::storage::btree::BasicKV* remove_index_;

  Session update_session_;

  Session remove_session_;

public:
  HistoryStorage() : update_index_(nullptr), remove_index_(nullptr) {
  }

  ~HistoryStorage() = default;

  leanstore::storage::btree::BasicKV* GetUpdateIndex() {
    return update_index_;
  }

  void SetUpdateIndex(leanstore::storage::btree::BasicKV* update_index) {
    update_index_ = update_index;
  }

  leanstore::storage::btree::BasicKV* GetRemoveIndex() {
    return remove_index_;
  }

  void SetRemoveIndex(leanstore::storage::btree::BasicKV* remove_index) {
    remove_index_ = remove_index;
  }

  void PutVersion(lean_txid_t tx_id, lean_cmdid_t command_id, lean_treeid_t tree_id, bool is_remove,
                  uint64_t payload_length, std::function<void(uint8_t*)> cb,
                  bool same_thread = true);

  bool GetVersion(lean_txid_t newer_tx_id, lean_cmdid_t newer_command_id,
                  const bool is_remove_command, std::function<void(const uint8_t*, uint64_t)> cb);

  void PurgeVersions(lean_txid_t from_tx_id, lean_txid_t to_tx_id, RemoveVersionCallback cb,
                     const uint64_t limit);

  void VisitRemovedVersions(lean_txid_t from_tx_id, lean_txid_t to_tx_id, RemoveVersionCallback cb);
};

} // namespace leanstore::cr

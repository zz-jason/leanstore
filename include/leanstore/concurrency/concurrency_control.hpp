#pragma once

#include "coroutine/lean_mutex.hpp"
#include "leanstore/common/types.h"
#include "leanstore/concurrency/history_storage.hpp"
#include "leanstore/cpp/base/constants.hpp"
#include "leanstore/cpp/base/log.hpp"
#include "leanstore/cpp/base/optional.hpp"
#include "leanstore/sync/hybrid_mutex.hpp"

#include <atomic>
#include <memory>
#include <utility>
#include <vector>

namespace leanstore {

/// Forward declarations
class LeanStore;

/// The commit log of the current worker thread. It's used for MVCC visibility check. It's a vector
/// of (commitTs, startTs) pairs. Everytime when a transaction is committed, a (commitTs, startTs)
/// pair is appended to the commit log. It's compacted according to the current active transactions
/// in the system when full.
class CommitTree {
public:
  /// The hybrid latch to guard the commit log.
  HybridMutex latch_;

  /// The capacity of the commit log. Commit log is compacted when full.
  uint64_t capacity_;

  /// The vector to store all the (commitTs, startTs) pairs.
  std::vector<std::pair<lean_txid_t, lean_txid_t>> commit_log_;

  /// Constructor.
  explicit CommitTree(const uint64_t num_workers) : capacity_(num_workers + 1) {
    commit_log_.reserve(capacity_);
  }

  /// AppendCommitLog is called when a transaction is committed. It appends the (commitTs, startTs)
  /// pair to the commit log. Transactions are sequential in one worker, so the commitTs and startTs
  /// are also increasing in the commit log of one worker
  /// @param startTs: the start timestamp of the transaction.
  /// @param commitTs: the commit timestamp of the transaction.
  void AppendCommitLog(lean_txid_t start_ts, lean_txid_t commit_ts);

  /// CompactCommitLog is called when the commit log is full in the begging of a transaction. It
  /// keeps the latest (commitTs, startTs) in the commit log, and the commit log that is visible for
  /// other running transactions.  All the unused commit logs are removed in this function.
  void CompactCommitLog();

  /// Lcb is short for Last Committed Before. LCB(self, startTs) returns the largest transaction id
  /// that is committed before the given timestamp on the current. Given a start timestamp, it's
  /// read view can be determined by all the LCB calls on all the worker threads.
  /// @param txId: the transaction id to check.
  /// @return: the last committed transaction id before the given timestamp.
  lean_txid_t Lcb(lean_txid_t tx_id);

private:
  /// LcbNoLatch is the same as Lcb, but it doesn't acquire the latch on the commit log.
  Optional<std::pair<lean_txid_t, lean_txid_t>> LcbUnlocked(lean_txid_t start_ts);
};

/// The global watermark info. It's used to store the global watermarks of all the worker threads.
struct WatermarkInfo {
  /// The write mutex to guard all the global watermark info, including the active transaction info
  /// and the watermark info.
  LeanSharedMutex global_mutex_;

  /// The oldest active transaction id in the store.
  std::atomic<lean_txid_t> oldest_active_tx_;

  /// The oldest active short-running transaction id in the store.
  std::atomic<lean_txid_t> oldest_active_short_tx_;

  /// The newest active long-running transaction id in the store.
  std::atomic<lean_txid_t> newest_active_long_tx_;

  /// The watermark of all the transactions, versions generated by transactions with id in the range
  /// [0, wmk_of_all_tx_] can be completely removed.
  std::atomic<lean_txid_t> wmk_of_all_tx_;

  /// The watermark of short-running transactions, versions generated by short-running transactions
  /// with id in the range (wmk_of_all_tx_, wmk_of_short_tx_] can be moved to the graveyard.
  std::atomic<lean_txid_t> wmk_of_short_tx_;

  /// Update the active transaction info.
  /// Precondition: the caller should acquire the write lock of global_mutex_.
  void UpdateActiveTxInfo(lean_txid_t oldest_tx, lean_txid_t oldest_short_tx,
                          lean_txid_t newest_long_tx) {
    oldest_active_tx_.store(oldest_tx, std::memory_order_release);
    oldest_active_short_tx_.store(oldest_short_tx, std::memory_order_release);
    newest_active_long_tx_.store(newest_long_tx, std::memory_order_release);
    LEAN_DLOG("Global watermark updated, oldestActiveTx={}, "
              "oldestActiveShortTx={}, netestActiveLongTx={}",
              oldest_active_tx_.load(), oldest_active_short_tx_.load(),
              newest_active_long_tx_.load());
  }

  /// Update the global watermarks.
  /// Precondition: the caller should acquire the write lock of global_mutex_.
  void UpdateWmks(lean_txid_t wmk_of_all, lean_txid_t wmk_of_short) {
    wmk_of_all_tx_.store(wmk_of_all, std::memory_order_release);
    wmk_of_short_tx_.store(wmk_of_short, std::memory_order_release);
    LEAN_DLOG("Global watermarks updated, wmkOfAllTx={}, wmkOfShortTx={}", wmk_of_all_tx_.load(),
              wmk_of_short_tx_.load());
  }

  /// Whether there is any active long-running transaction.
  bool HasActiveLongRunningTx() {
    return oldest_active_tx_ != oldest_active_short_tx_;
  }
};

/// The version storage of the current worker thread. All the history versions of transaction
/// removes and updates, all the necessary commit log for MVCC visibility check are stored here.
class ConcurrencyControl {
public:
  ConcurrencyControl(LeanStore* store, uint64_t num_workers)
      : store_(store),
        commit_tree_(num_workers) {
    lcb_cache_val_ = std::make_unique<uint64_t[]>(num_workers);
    lcb_cache_key_ = std::make_unique<uint64_t[]>(num_workers);
  }

  /// The LeanStore it belongs to.
  LeanStore* store_;

  /// The history storage of current worker thread. All history versions of transaction removes and
  /// updates executed by current worker are stored here. It's the version storage of the chained
  /// tuple. Used for MVCC.
  HistoryStorage history_storage_;

  /// The commit log on the current worker. Used for MVCC visibility check.
  CommitTree commit_tree_;

  /// The start timestamp used to calculate the LCB of the target worker.
  std::unique_ptr<lean_txid_t[]> lcb_cache_key_;

  /// The LCB of the target worker on the LCB cache key.
  std::unique_ptr<lean_txid_t[]> lcb_cache_val_;

  /// The optismistic latch to guard wmk_of_short_tx_ and wmk_of_all_tx_. There is at most one
  /// writer at a time, we can safely check whether the version is odd to verify whether the
  /// watermarks are being updated at the time to read.
  std::atomic<lean_txid_t> wmk_version_ = 0;

  /// Versions (tombstones, updates, etc.) generated by all the short-running and long-running
  /// transactions whose id in the range [0, wmk_of_all_tx_] can be completely removed.
  std::atomic<lean_txid_t> wmk_of_all_tx_;

  /// Tombstones generated by all the short-running transactions whose id in the range
  /// (wmk_of_all_tx_, wmk_of_short_tx_] can be moved to the graveyard. So that newer transactions
  /// can avoid seeing them when traversing the main btree, which saves the performance.
  std::atomic<lean_txid_t> wmk_of_short_tx_;

  /// The latest commit timestamp of the current worker thread. It's updated everytime when a
  /// transaction is committed.
  std::atomic<lean_txid_t> latest_commit_ts_ = 0;

  /// The latest commit timestamp of the current worker thread.
  std::atomic<lean_txid_t> updated_latest_commit_ts_ = 0;

  /// Tombstones generated by all the short-running transactions whose id is in the range [0,
  /// cleaned_wmk_of_short_tx_) are all moved to tombstone. It is reset after each GC round.
  lean_txid_t cleaned_wmk_of_short_tx_ = 0;

  /// A snapshot of wmk_of_all_tx_, copied from wmk_of_all_tx_ at the beginning of each round of
  /// garbage collection.
  lean_txid_t local_wmk_of_all_tx_;

  /// A snapshot of wmk_of_short_tx_, copied from wmk_of_short_tx_ at the beginning of each round of
  /// garbage collection.
  lean_txid_t local_wmk_of_short_tx_;

  /// A snapshot of global watermark, copied from global watermark info at the beginning of each
  /// transaction start. Used for visibility check of the current transaction.
  lean_txid_t global_wmk_of_all_tx_ = 0;

  /// Get the older version in version storage according to the given (newerWorkerId, newerTxId,
  /// newerCommandId). The callback function is called with the version data when the version is
  /// found.
  ///
  /// NOTE: Version is retrieved from newest to oldest.
  ///
  /// @param newerWorkerId: the worker id of the newer version.
  /// @param newerTxId: the transaction id of the newer version.
  /// @param newerCommandId: the command id of the newer version.
  /// @param getCallback: the callback function to be called when the version is found.
  /// @return: true if the version is found, false otherwise.
  bool GetVersion(lean_wid_t newer_worker_id, lean_txid_t newer_tx_id,
                  lean_cmdid_t newer_command_id,
                  std::function<void(const uint8_t*, uint64_t version_size)> get_callback) {
    auto is_remove_command = newer_command_id & kCmdRemoveMark;
    return Other(newer_worker_id)
        .history_storage_.GetVersion(newer_tx_id, newer_command_id, is_remove_command,
                                     get_callback);
  }

  /// Put a version to the version storage. The callback function is called with the version data
  /// when the version is inserted, usually used to initialize the actual version payload.
  lean_cmdid_t PutVersion(lean_treeid_t tree_id, bool is_remove_command, uint64_t version_size,
                          std::function<void(uint8_t*)> put_callback);

  /// Whether a tuple written by workerId in txId is visible for the current active transaction.
  bool VisibleForMe(lean_wid_t worker_id, lean_txid_t tx_id);

  /// Whether a tuple written in txId is visible for all the current active transactions.
  bool VisibleForAll(lean_txid_t tx_id);

  /// Garbage collect the version storage. It's called at the end of each transaction. It updates
  /// the global and local watermarks, and removes the unused versions from the version storage.
  void GarbageCollection();

  /// Get the version storge in other worker thread.
  ConcurrencyControl& Other(lean_wid_t other_worker_id);

private:
  /// Update global watermarks of all the worker threads before GC.
  void UpdateGlobalWmks();

  /// Update local watermarks of the current worker thread before GC.
  void UpdateLocalWmks();
};

} // namespace leanstore
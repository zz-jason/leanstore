#pragma once

#include "leanstore/concurrency/history_storage.hpp"
#include "leanstore/lean_store.hpp"
#include "leanstore/sync/hybrid_mutex.hpp"
#include "leanstore/units.hpp"
#include "leanstore/utils/log.hpp"
#include "utils/coroutine/lean_mutex.hpp"

#include <atomic>
#include <memory>
#include <optional>
#include <utility>
#include <vector>

namespace leanstore {
class LeanStore;
} // namespace leanstore

namespace leanstore::cr {

/// The commit log of the current worker thread. It's used for MVCC visibility check. It's a vector
/// of (commitTs, startTs) pairs. Everytime when a transaction is committed, a (commitTs, startTs)
/// pair is appended to the commit log. It's compacted according to the current active transactions
/// in the system when full.
class CommitTree {
public:
  /// The hybrid latch to guard the commit log.
  storage::HybridMutex latch_;

  /// The capacity of the commit log. Commit log is compacted when full.
  uint64_t capacity_;

  /// The vector to store all the (commitTs, startTs) pairs.
  std::vector<std::pair<TXID, TXID>> commit_log_;

public:
  /// Constructor.
  CommitTree(const uint64_t num_workers) : capacity_(num_workers + 1) {
    commit_log_.reserve(capacity_);
  }

public:
  /// AppendCommitLog is called when a transaction is committed. It appends the (commitTs, startTs)
  /// pair to the commit log. Transactions are sequential in one worker, so the commitTs and startTs
  /// are also increasing in the commit log of one worker
  /// @param startTs: the start timestamp of the transaction.
  /// @param commitTs: the commit timestamp of the transaction.
  void AppendCommitLog(TXID start_ts, TXID commit_ts);

  /// CompactCommitLog is called when the commit log is full in the begging of a transaction. It
  /// keeps the latest (commitTs, startTs) in the commit log, and the commit log that is visible for
  /// other running transactions.  All the unused commit logs are removed in this function.
  void CompactCommitLog();

  /// Lcb is short for Last Committed Before. LCB(self, startTs) returns the largest transaction id
  /// that is committed before the given timestamp on the current. Given a start timestamp, it's
  /// read view can be determined by all the LCB calls on all the worker threads.
  /// @param txId: the transaction id to check.
  /// @return: the last committed transaction id before the given timestamp.
  TXID Lcb(TXID tx_id);

private:
  /// LcbNoLatch is the same as Lcb, but it doesn't acquire the latch on the commit log.
  std::optional<std::pair<TXID, TXID>> LcbUnlocked(TXID start_ts);
};

/// The global watermark info. It's used to store the global watermarks of all the worker threads.
struct WatermarkInfo {
  /// The write mutex to guard all the global watermark info, including the active transaction info
  /// and the watermark info.
  LeanSharedMutex global_mutex_;

  /// The oldest active transaction id in the store.
  std::atomic<TXID> oldest_active_tx_;

  /// The oldest active short-running transaction id in the store.
  std::atomic<TXID> oldest_active_short_tx_;

  /// The newest active long-running transaction id in the store.
  std::atomic<TXID> newest_active_long_tx_;

  /// The watermark of all the transactions, versions generated by transactions with id in the range
  /// [0, wmk_of_all_tx_] can be completely removed.
  std::atomic<TXID> wmk_of_all_tx_;

  /// The watermark of short-running transactions, versions generated by short-running transactions
  /// with id in the range (wmk_of_all_tx_, wmk_of_short_tx_] can be moved to the graveyard.
  std::atomic<TXID> wmk_of_short_tx_;

  /// Update the active transaction info.
  /// Precondition: the caller should acquire the write lock of global_mutex_.
  void UpdateActiveTxInfo(TXID oldest_tx, TXID oldest_short_tx, TXID newest_long_tx) {
    oldest_active_tx_.store(oldest_tx, std::memory_order_release);
    oldest_active_short_tx_.store(oldest_short_tx, std::memory_order_release);
    newest_active_long_tx_.store(newest_long_tx, std::memory_order_release);
    LS_DLOG("Global watermark updated, oldestActiveTx={}, "
            "oldestActiveShortTx={}, netestActiveLongTx={}",
            oldest_active_tx_.load(), oldest_active_short_tx_.load(),
            newest_active_long_tx_.load());
  }

  /// Update the global watermarks.
  /// Precondition: the caller should acquire the write lock of global_mutex_.
  void UpdateWmks(TXID wmk_of_all, TXID wmk_of_short) {
    wmk_of_all_tx_.store(wmk_of_all, std::memory_order_release);
    wmk_of_short_tx_.store(wmk_of_short, std::memory_order_release);
    LS_DLOG("Global watermarks updated, wmkOfAllTx={}, wmkOfShortTx={}", wmk_of_all_tx_.load(),
            wmk_of_short_tx_.load());
  }

  /// Whether there is any active long-running transaction.
  bool HasActiveLongRunningTx() {
    return oldest_active_tx_ != oldest_active_short_tx_;
  }
};

/// The version storage of the current worker thread. All the history versions of transaction
/// removes and updates, all the necessary commit log for MVCC visibility check are stored here.
class ConcurrencyControl {
public:
  ConcurrencyControl(leanstore::LeanStore* store, uint64_t num_workers)
      : store_(store),
        commit_tree_(num_workers) {
  }

public:
  /// The LeanStore it belongs to.
  leanstore::LeanStore* store_;

  /// The history storage of current worker thread. All history versions of transaction removes and
  /// updates executed by current worker are stored here. It's the version storage of the chained
  /// tuple. Used for MVCC.
  HistoryStorage history_storage_;

  /// The commit log on the current worker. Used for MVCC visibility check.
  CommitTree commit_tree_;

  /// The start timestamp used to calculate the LCB of the target worker.
  std::unique_ptr<TXID[]> lcb_cache_key_;

  /// The LCB of the target worker on the LCB cache key.
  std::unique_ptr<TXID[]> lcb_cache_val_;

  /// The optismistic latch to guard wmk_of_short_tx_ and wmk_of_all_tx_. There is at most one
  /// writer at a time, we can safely check whether the version is odd to verify whether the
  /// watermarks are being updated at the time to read.
  std::atomic<TXID> wmk_version_ = 0;

  /// Versions (tombstones, updates, etc.) generated by all the short-running and long-running
  /// transactions whose id in the range [0, wmk_of_all_tx_] can be completely removed.
  std::atomic<TXID> wmk_of_all_tx_;

  /// Tombstones generated by all the short-running transactions whose id in the range
  /// (wmk_of_all_tx_, wmk_of_short_tx_] can be moved to the graveyard. So that newer transactions
  /// can avoid seeing them when traversing the main btree, which saves the performance.
  std::atomic<TXID> wmk_of_short_tx_;

  /// The latest commit timestamp of the current worker thread. It's updated everytime when a
  /// transaction is committed.
  std::atomic<TXID> latest_commit_ts_ = 0;

  /// The latest commit timestamp of the current worker thread.
  std::atomic<TXID> updated_latest_commit_ts_ = 0;

  /// Tombstones generated by all the short-running transactions whose id is in the range [0,
  /// cleaned_wmk_of_short_tx_) are all moved to tombstone. It is reset after each GC round.
  TXID cleaned_wmk_of_short_tx_ = 0;

  /// A snapshot of wmk_of_all_tx_, copied from wmk_of_all_tx_ at the beginning of each round of
  /// garbage collection.
  TXID local_wmk_of_all_tx_;

  /// A snapshot of wmk_of_short_tx_, copied from wmk_of_short_tx_ at the beginning of each round of
  /// garbage collection.
  TXID local_wmk_of_short_tx_;

  /// A snapshot of global watermark, copied from global watermark info at the beginning of each
  /// transaction start. Used for visibility check of the current transaction.
  TXID global_wmk_of_all_tx_ = 0;

public:
  /// Get the older version in version storage according to the given (newerWorkerId, newerTxId,
  /// newerCommandId). The callback function is called with the version data when the version is
  /// found.
  ///
  /// NOTE: Version is retrieved from newest to oldest.
  ///
  /// @param newerWorkerId: the worker id of the newer version.
  /// @param newerTxId: the transaction id of the newer version.
  /// @param newerCommandId: the command id of the newer version.
  /// @param getCallback: the callback function to be called when the version is found.
  /// @return: true if the version is found, false otherwise.
  inline bool GetVersion(WORKERID newer_worker_id, TXID newer_tx_id, COMMANDID newer_command_id,
                         std::function<void(const uint8_t*, uint64_t version_size)> get_callback) {
    auto is_remove_command = newer_command_id & kRemoveCommandMark;
    return Other(newer_worker_id)
        .history_storage_.GetVersion(newer_tx_id, newer_command_id, is_remove_command,
                                     get_callback);
  }

  /// Put a version to the version storage. The callback function is called with the version data
  /// when the version is inserted, usually used to initialize the actual version payload.
  COMMANDID PutVersion(TREEID tree_id, bool is_remove_command, uint64_t version_size,
                       std::function<void(uint8_t*)> put_callback);

  /// Whether a tuple written by workerId in txId is visible for the current active transaction.
  bool VisibleForMe(WORKERID worker_id, TXID tx_id);

  /// Whether a tuple written in txId is visible for all the current active transactions.
  bool VisibleForAll(TXID tx_id);

  /// Garbage collect the version storage. It's called at the end of each transaction. It updates
  /// the global and local watermarks, and removes the unused versions from the version storage.
  void GarbageCollection();

  /// Get the version storge in other worker thread.
  ConcurrencyControl& Other(WORKERID other_worker_id);

private:
  /// Update global watermarks of all the worker threads before GC.
  void UpdateGlobalWmks();

  /// Update local watermarks of the current worker thread before GC.
  void UpdateLocalWmks();
};

} // namespace leanstore::cr
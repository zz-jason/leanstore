#pragma once

#include "KVInterface.hpp"
#include "LeanStore.hpp"
#include "concurrency-recovery/Worker.hpp"
#include "leanstore/Store.hpp"
#include "shared-headers/Units.hpp"
#include "storage/btree/TransactionKV.hpp"
#include "storage/btree/core/BTreeGeneric.hpp"
#include "utils/Error.hpp"

#include <cstring>
#include <expected>
#include <iostream>
#include <memory>
#include <string>

namespace leanstore {

class TransactionKVStore : public Store {
private:
  std::unique_ptr<LeanStore> mStore;

public:
  TransactionKVStore(const std::string& dataDir) {
    FLAGS_init = true;
    FLAGS_data_dir = dataDir;

    auto res = LeanStore::Open();
    if (!res) {
      std::cerr << "Failed to open leanstore: " << res.error().ToString()
                << std::endl;
      exit(res.error().Code());
    }

    mStore = std::move(res.value());
  }

  virtual ~TransactionKVStore() = default;

  /// Get a transaction worker, all the transaction operations are dispatched
  /// to the worker thread.
  virtual std::expected<std::unique_ptr<TxWorker>, utils::Error> GetTxWorker(
      WORKERID workerId);

  /// Execute a custom user function on a worker thread.
  virtual void ExecSync(WORKERID workerId, std::function<void()> fn) {
    mStore->ExecSync(workerId, fn);
  }

  /// Execute a custom user function on a worker thread asynchronously. It's
  /// expected to call this function with Wait(). For example:
  ///   store.ExecAsync(0, []() { /* do something */ });
  ///   /* do something else ... */
  ///   store.Wait(0);
  virtual void ExecAsync(WORKERID workerId, std::function<void()> fn) {
    mStore->ExecAsync(workerId, fn);
  }

  /// Wait the completion of the execution of a custom user function on a worker
  /// thread.
  virtual void Wait(WORKERID workerId) {
    mStore->Wait(workerId);
  }
};

class TransactionKVTxWorker : public TxWorker {
private:
  LeanStore* mStore;
  WORKERID mWorkerId;

public:
  TransactionKVTxWorker(LeanStore* store, WORKERID workerId)
      : mStore(store),
        mWorkerId(workerId) {
  }

  virtual ~TransactionKVTxWorker() = default;

  /// Start a transaction.
  virtual std::expected<void, utils::Error> StartTx(TxMode mode,
                                                    IsolationLevel level,
                                                    bool isReadOnly) {
    mStore->ExecSync(mWorkerId, [&]() {
      cr::Worker::My().StartTx(mode, level, isReadOnly);
    });
    return {};
  }

  /// Commit a transaction.
  virtual std::expected<void, utils::Error> CommitTx() {
    mStore->ExecSync(mWorkerId, [&]() { cr::Worker::My().CommitTx(); });
    return {};
  }

  /// Abort a transaction.
  virtual std::expected<void, utils::Error> AbortTx() {
    mStore->ExecSync(mWorkerId, [&]() { cr::Worker::My().CommitTx(); });
    return {};
  }

  /// Create a table, should be executed inside a transaction.
  virtual std::expected<TableRef, utils::Error> CreateTable(
      const std::string& name) {
    btree::TransactionKV* table;
    mStore->ExecSync(mWorkerId, [&]() {
      auto config = storage::btree::BTreeConfig{
          .mEnableWal = true,
          .mUseBulkInsert = false,
      };

      mStore->CreateTransactionKV(name, config, &table);
    });
    return table;
  }

  /// Get a table, should be executed inside a transaction.
  virtual std::expected<TableRef, utils::Error> GetTable(
      const std::string& name) {
    btree::TransactionKV* table;
    mStore->ExecSync(mWorkerId, [&]() {
      btree::TransactionKV* table;
      mStore->GetTransactionKV(name, &table);
    });
    return table;
  }

  /// Drop a table, should be executed inside a transaction.
  virtual std::expected<void, utils::Error> DropTable(const std::string& name) {
    mStore->ExecSync(mWorkerId, [&]() { mStore->DropTransactionKV(name); });
    return {};
  }

  /// Put a key-value pair into a table, should be executed inside a
  /// transaction.
  virtual std::expected<void, utils::Error> Put(TableRef table, Slice key,
                                                Slice value) {
    OpCode ret(OpCode::kOK);
    mStore->ExecSync(mWorkerId, [&]() {
      auto* kv = reinterpret_cast<btree::TransactionKV*>(table);
      ret = kv->Insert(key, value);
    });

    if (ret == OpCode::kOK) {
      return {};
    }

    return std::unexpected<utils::Error>(
        utils::Error::General("Failed to insert"));
  }

  /// Update a key-value pair from a table, should be executed inside a
  /// transaction.
  virtual std::expected<void, utils::Error> Update(TableRef table
                                                   [[maybe_unused]],
                                                   Slice key [[maybe_unused]],
                                                   Slice value
                                                   [[maybe_unused]]) {
    LOG(FATAL) << "Update is unsupported";
    return {};
  }

  /// Delete a key-value pair from a table, should be executed inside a
  /// transaction.
  virtual std::expected<void, utils::Error> Delete(TableRef table, Slice key) {
    OpCode ret(OpCode::kOK);
    mStore->ExecSync(mWorkerId, [&]() {
      auto* kv = reinterpret_cast<btree::TransactionKV*>(table);
      ret = kv->Remove(key);
    });

    if (ret != OpCode::kOK) {
      return std::unexpected<utils::Error>(
          utils::Error::General("Failed to delete: " + ToString(ret)));
    }

    return {};
  }

  /// Get a key-value pair from a table, should be executed inside a
  /// transaction.
  virtual std::expected<void, utils::Error> Get(TableRef table, Slice key,
                                                std::string* value) {
    OpCode ret(OpCode::kOK);
    mStore->ExecSync(mWorkerId, [&]() {
      auto* kv = reinterpret_cast<btree::TransactionKV*>(table);
      auto copyValue = [&](Slice val) {
        value->resize(val.size());
        std::memcpy(value->data(), val.data(), val.size());
      };
      ret = kv->Lookup(key, copyValue);
    });

    if (ret != OpCode::kOK) {
      return std::unexpected<utils::Error>(
          utils::Error::General("Failed to get: " + ToString(ret)));
    }

    return {};
  }

  /*
  /// Create an iterator to scan a table, should be executed inside a
  /// transaction.
  virtual std::expected<std::unique_ptr<TableIterator>, utils::Error>
  NewTableIterator(TableRef table [[maybe_unused]]) {
    LOG(FATAL) << "NewTableIterator is unsupported";
    return {};
  }
  */

  /// Get the total key-value pairs in a table, should be executed inside a
  /// transaction.
  virtual std::expected<u64, utils::Error> GetTableSize(TableRef table) {
    u64 ret(0);
    mStore->ExecSync(mWorkerId, [&]() {
      auto* kv = reinterpret_cast<btree::TransactionKV*>(table);
      ret = kv->CountEntries();
    });
    return ret;
  }
};

inline std::expected<std::unique_ptr<TxWorker>, utils::Error>
TransactionKVStore::GetTxWorker(WORKERID workerId) {
  return std::unique_ptr<TxWorker>(
      new TransactionKVTxWorker(mStore.get(), workerId));
}

} // namespace leanstore